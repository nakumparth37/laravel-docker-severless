# .github/workflows/deploy.yml
name: Laravel Fargate CI/CD

on:
  push:
    branches:
      - main

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: ${{ secrets.ECR_REGISTRY }}/laravel-php
  CLUSTER_NAME: laravel-cluster37
  SERVICE_NAME: laravel-php-service
  TASK_DEFINITION_FILE: deploy/ecs/laravel-task.json

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    # 1 Checkout code
    - name: Checkout code
      uses: actions/checkout@v3

    # 2 Configure AWS credentials
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # 3 Create .env dynamically
    - name: Create .env file
      run: |
        cat <<EOF > .env
          APP_NAME=Serverless-App
          APP_ENV=production
          APP_KEY=${{ secrets.APP_KEY }}
          APP_DEBUG=false
          APP_URL=https://your-alb-dns

          DB_CONNECTION=mysql
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=3306
          DB_DATABASE=laravel_db
          DB_USERNAME=admin
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          QUEUE_CONNECTION=sqs
          SQS_PREFIX=https://sqs.ap-south-1.amazonaws.com/136003615631
          SQS_QUEUE=laravel-queue

          FILESYSTEM_DISK=s3
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION=ap-south-1
          AWS_BUCKET=${{ secrets.AWS_BUCKET }}
          AWS_USE_PATH_STYLE_ENDPOINT=false
          AWS_URL=https://laravel-dev-aws-storage.s3.amazonaws.com

          SESSION_DRIVER=cookie
          CACHE_DRIVER=file

          MAIL_MAILER=smtp
          MAIL_HOST=mail.mailtest.radixweb.net
          MAIL_PORT=587
          MAIL_USERNAME=testphp@mailtest.radixweb.net
          MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
          MAIL_ENCRYPTION=null
          MAIL_FROM_ADDRESS=testmobile@mailtest.radixweb.net
          MAIL_FROM_NAME=Serverless-App

          GITHUB_CLIENT_ID=${{ secrets.OAUTH_GITHUB_CLIENT_ID }}
          GITHUB_CLIENT_SECRET=${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}
          OAUTH_REDIRECT_URL=https://your-alb-dns/login/github/callback

          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT=https://your-alb-dns/login/google/callback

          PAYPAL_MODE=sandbox
          PAYPAL_SANDBOX_CLIENT_ID=${{ secrets.PAYPAL_SANDBOX_CLIENT_ID }}
          PAYPAL_SANDBOX_CLIENT_SECRET=${{ secrets.PAYPAL_SANDBOX_CLIENT_SECRET }}

          PASSPORT_PERSONAL_ACCESS_CLIENT_ID=6
          PASSPORT_PERSONAL_ACCESS_CLIENT_SECRET=${{ secrets.PASSPORT_PERSONAL_ACCESS_CLIENT_SECRET }}
          SEEDER_SECRET=${{ secrets.SEEDER_SECRET }}
          EOF

    # 4 Login to Amazon ECR
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REPOSITORY }}

    # 5 Build Docker image
    - name: Build Docker Image
      run: |
        docker build -f deploy/ecs/Dockerfile -t ${{ env.ECR_REPOSITORY }}:latest .

    # 6 Push Docker image to ECR
    - name: Push Docker Image
      run: |
        docker push ${{ env.ECR_REPOSITORY }}:latest

    # 7. Update Task Definition image (remove enableExecuteCommand)
    - name: Update Task Definition
      run: |
        jq --arg IMAGE "${{ env.ECR_REPOSITORY }}:latest" \
        'del(.enableExecuteCommand) | .containerDefinitions[0].image = $IMAGE' \
        ${{ env.TASK_DEFINITION_FILE }} > task-def.json

    # 8. Register ECS Task Definition
    - name: Register ECS Task Definition
      id: register-task
      run: |
        TASK_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-def.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        echo "TASK_DEFINITION_ARN=$TASK_ARN" >> $GITHUB_ENV

    - name: Ensure ECS service exists
      run: |
        SERVICE=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} \
            --services ${{ env.SERVICE_NAME }} \
            --query "services[0].status" \
            --output text)
        if [ "$SERVICE" == "None" ] || [ -z "$SERVICE" ]; then
            echo "Service not found. Creating ECS service..."
            aws ecs create-service \
              --cluster ${{ env.CLUSTER_NAME }} \
              --service-name ${{ env.SERVICE_NAME }} \
              --task-definition ${{ env.TASK_DEFINITION_ARN }} \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[subnet-07b19d6f11571ee15,subnet-00fec2f12e9d6b568,subnet-0790112de9054aa3d],securityGroups=[sg-0660b09322887db31],assignPublicIp=ENABLED}" \
              --region ${{ env.AWS_REGION }}
        else
            echo "Service exists: $SERVICE"
        fi

    # 9. Update ECS Service
    - name: Update ECS Service
      run: |
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --task-definition ${{ env.TASK_DEFINITION_ARN }} \
          --force-new-deployment

    # 10. Enable Execute Command
    - name: Enable Execute Command on ECS Service
      run: |
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --enable-execute-command

    # 11. Wait for ECS service stability
    - name: Wait for ECS service stability
      run: |
        aws ecs wait services-stable \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services ${{ env.SERVICE_NAME }}
